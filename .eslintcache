[{"/Users/gregfoster/graphite-cli/src/commands/abstract_command.ts":"1","/Users/gregfoster/graphite-cli/src/commands/amend/index.ts":"2","/Users/gregfoster/graphite-cli/src/commands/demo/index.ts":"3","/Users/gregfoster/graphite-cli/src/commands/diff/index.ts":"4","/Users/gregfoster/graphite-cli/src/commands/fix/index.ts":"5","/Users/gregfoster/graphite-cli/src/commands/log/index.ts":"6","/Users/gregfoster/graphite-cli/src/commands/next-or-prev/index.ts":"7","/Users/gregfoster/graphite-cli/src/commands/print-stacks/index.ts":"8","/Users/gregfoster/graphite-cli/src/commands/restack/index.ts":"9","/Users/gregfoster/graphite-cli/src/commands/submit/index.ts":"10","/Users/gregfoster/graphite-cli/src/commands/validate/index.ts":"11","/Users/gregfoster/graphite-cli/src/index.ts":"12","/Users/gregfoster/graphite-cli/src/lib/log/index.ts":"13","/Users/gregfoster/graphite-cli/src/lib/telemetry/index.ts":"14","/Users/gregfoster/graphite-cli/src/lib/utils/index.ts":"15","/Users/gregfoster/graphite-cli/src/wrapper-classes/branch.ts":"16","/Users/gregfoster/graphite-cli/src/wrapper-classes/commit.ts":"17"},{"size":774,"mtime":1626702253973,"results":"18","hashOfConfig":"19"},{"size":813,"mtime":1626702187631,"results":"20","hashOfConfig":"19"},{"size":1951,"mtime":1626702182342,"results":"21","hashOfConfig":"19"},{"size":1300,"mtime":1626702176787,"results":"22","hashOfConfig":"19"},{"size":3333,"mtime":1626702168919,"results":"23","hashOfConfig":"19"},{"size":726,"mtime":1626702162969,"results":"24","hashOfConfig":"19"},{"size":1398,"mtime":1626702157349,"results":"25","hashOfConfig":"19"},{"size":4589,"mtime":1626702149324,"results":"26","hashOfConfig":"19"},{"size":4107,"mtime":1626701864448,"results":"27","hashOfConfig":"19"},{"size":2714,"mtime":1626628235141,"results":"28","hashOfConfig":"19"},{"size":1980,"mtime":1626702138484,"results":"29","hashOfConfig":"19"},{"size":3354,"mtime":1626628235142,"results":"30","hashOfConfig":"19"},{"size":175,"mtime":1626702093702,"results":"31","hashOfConfig":"19"},{"size":1007,"mtime":1626702123493,"results":"32","hashOfConfig":"19"},{"size":1792,"mtime":1626702271895,"results":"33","hashOfConfig":"19"},{"size":6507,"mtime":1626702087259,"results":"34","hashOfConfig":"19"},{"size":649,"mtime":1626702279549,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"wa313f",{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"67","messages":"68","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76"},"/Users/gregfoster/graphite-cli/src/commands/abstract_command.ts",[],"/Users/gregfoster/graphite-cli/src/commands/amend/index.ts",[],"/Users/gregfoster/graphite-cli/src/commands/demo/index.ts",["77"],"import { execSync } from \"child_process\";\nimport tmp from \"tmp\";\nimport yargs from \"yargs\";\nimport GitRepo from \"../../../test/utils/git_repo\";\nimport AbstractCommand from \"../abstract_command\";\n\nconst args = {} as const;\ntype argsT = yargs.Arguments<yargs.InferredOptionTypes<typeof args>>;\nexport default class DemoCommand extends AbstractCommand<typeof args> {\n  static args = args;\n  public async _execute(argv: argsT): Promise<void> {\n    const tmpDir = tmp.dirSync();\n    console.log(tmpDir.name);\n    const repo = new GitRepo(tmpDir.name);\n\n    repo.createChangeAndCommit(\"First commit\");\n    repo.createChangeAndCommit(\"Second commit\");\n\n    repo.createChange(\"[Product] Add review queue filter api\");\n    execCliCommand(\n      \"diff -b 'tr--review_queue_api' -m '[Product] Add review queue filter api'\",\n      { fromDir: tmpDir.name }\n    );\n\n    repo.createChange(\"[Product] Add review queue filter server\");\n    execCliCommand(\n      \"diff -b 'tr--review_queue_server' -m '[Product] Add review queue filter server'\",\n      { fromDir: tmpDir.name }\n    );\n\n    repo.createChange(\"[Product] Add review queue filter frontend\");\n    execCliCommand(\n      \"diff -b 'tr--review_queue_frontend' -m '[Product] Add review queue filter frontend'\",\n      { fromDir: tmpDir.name }\n    );\n\n    repo.checkoutBranch(\"main\");\n\n    repo.createChange(\"[Bug Fix] Fix crashes on reload\");\n    execCliCommand(\n      \"diff -b 'tr--fix_crash_on_reload' -m '[Bug Fix] Fix crashes on reload'\",\n      { fromDir: tmpDir.name }\n    );\n\n    repo.checkoutBranch(\"main\");\n\n    repo.createChange(\"[Bug Fix] Account for empty state\");\n    execCliCommand(\n      \"diff -b 'tr--account_for_empty_state' -m '[Bug Fix] Account for empty state'\",\n      { fromDir: tmpDir.name }\n    );\n\n    repo.checkoutBranch(\"main\");\n  }\n}\n\nfunction execCliCommand(command: string, opts: { fromDir: string }) {\n  execSync(`sd ${command}`, {\n    stdio: \"inherit\",\n    cwd: opts.fromDir,\n  });\n}\n","/Users/gregfoster/graphite-cli/src/commands/diff/index.ts",[],"/Users/gregfoster/graphite-cli/src/commands/fix/index.ts",[],"/Users/gregfoster/graphite-cli/src/commands/log/index.ts",["78"],"import { execSync } from \"child_process\";\nimport yargs from \"yargs\";\nimport AbstractCommand from \"../abstract_command\";\n\nconst args = {} as const;\ntype argsT = yargs.Arguments<yargs.InferredOptionTypes<typeof args>>;\nexport default class LogCommand extends AbstractCommand<typeof args> {\n  static args = args;\n  public async _execute(argv: argsT): Promise<void> {\n    try {\n      execSync(\n        `git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all`,\n        { stdio: \"inherit\" }\n      );\n    } catch (e) {\n      // Ignore errors (this just means they quit git log)\n    }\n  }\n}\n","/Users/gregfoster/graphite-cli/src/commands/next-or-prev/index.ts",["79","80"],"#!/usr/bin/env node\nimport chalk from \"chalk\";\nimport { execSync } from \"child_process\";\nimport yargs from \"yargs\";\nimport Branch from \"../../wrapper-classes/branch\";\nimport AbstractCommand from \"../abstract_command\";\n\nconst args = {} as const;\ntype argsT = yargs.Arguments<yargs.InferredOptionTypes<typeof args>>;\nexport class NextCommand extends AbstractCommand<typeof args> {\n  static args = args;\n  public async _execute(argv: argsT): Promise<void> {\n    await nextOrPrev(\"next\");\n  }\n}\nexport class PrevCommand extends AbstractCommand<typeof args> {\n  static args = args;\n  public async _execute(argv: argsT): Promise<void> {\n    await nextOrPrev(\"prev\");\n  }\n}\n\nasync function nextOrPrev(nextOrPrev: \"next\" | \"prev\") {\n  const currentBranch = Branch.getCurrentBranch();\n\n  const candidates =\n    nextOrPrev === \"next\"\n      ? await currentBranch.getChildrenFromGit()\n      : await currentBranch.getParentsFromGit();\n\n  if (candidates.length === 0) {\n    console.log(chalk.yellow(`Found no ${nextOrPrev} branch`));\n    process.exit(1);\n  }\n  if (candidates.length > 1) {\n    console.log(chalk.yellow(`Found multiple possibilities:`));\n    for (const candidate of candidates) {\n      console.log(chalk.yellow(` - ${candidate.name}`));\n    }\n    process.exit(1);\n  }\n\n  const branchName = candidates.values().next().value.name;\n  execSync(`git checkout \"${branchName}\"`, { stdio: \"ignore\" });\n}\n","/Users/gregfoster/graphite-cli/src/commands/print-stacks/index.ts",["81","82","83"],"import chalk from \"chalk\";\nimport { execSync } from \"child_process\";\nimport yargs from \"yargs\";\nimport Branch from \"../../wrapper-classes/branch\";\nimport AbstractCommand from \"../abstract_command\";\n\nconst args = {} as const;\ntype argsT = yargs.Arguments<yargs.InferredOptionTypes<typeof args>>;\n\nfunction computeDag(truth: \"GIT\" | \"META\"): {\n  dag: { [name: string]: string[] };\n  sourceBranches: string[];\n} {\n  const dag: { [name: string]: string[] } = {};\n  const sourceBranches: string[] = [];\n  Branch.allBranches().forEach((branch) => {\n    const parents =\n      truth == \"GIT\"\n        ? branch.getParentsFromGit() || []\n        : ([branch.getParentFromMeta()].filter(\n            (b) => b != undefined\n          ) as Branch[]);\n    if (parents.length > 0) {\n      parents.forEach((parent) => {\n        if (dag[parent.name]) {\n          dag[parent.name].push(branch.name);\n        } else {\n          dag[parent.name] = [branch.name];\n        }\n      });\n    } else {\n      sourceBranches.push(branch.name);\n    }\n  });\n  return { dag, sourceBranches };\n}\nexport default class PrintStacksCommand extends AbstractCommand<typeof args> {\n  static args = args;\n  public async _execute(argv: argsT): Promise<void> {\n    const gitInfo = computeDag(\"GIT\");\n    const metaInfo = computeDag(\"META\");\n\n    const currentBranch = Branch.getCurrentBranch();\n    if (currentBranch) {\n      console.log(`Current branch: ${chalk.green(`(${currentBranch.name})`)}`);\n    }\n\n    const dagsAreEqual =\n      Object.keys(gitInfo.dag).length == Object.keys(metaInfo.dag).length &&\n      Object.keys(gitInfo.dag).every(\n        (key) =>\n          metaInfo.dag[key].sort().join() == gitInfo.dag[key].sort().join()\n      );\n    if (dagsAreEqual) {\n      gitInfo.sourceBranches.forEach((sourceBranch) => {\n        dfsPrintBranches({\n          currentBranchName: currentBranch.name,\n          branchName: sourceBranch,\n          dag: gitInfo.dag,\n          depthIndents: [],\n        });\n      });\n    } else {\n      console.log(\n        [\n          chalk.yellow(`Git derived stack differs from meta derived stack.`),\n          `Run \"${chalk.green(\n            \"restack\"\n          )}\" to update the git stack to match the meta stack.`,\n          `Alternatively, run \"${chalk.green(\n            \"regen\"\n          )}\" to update the meta-stack to match the git-stack.\\n`,\n        ].join(\"\\n\")\n      );\n      console.log(`Git derived stacks:`);\n      gitInfo.sourceBranches.forEach((sourceBranch) => {\n        dfsPrintBranches({\n          currentBranchName: currentBranch.name,\n          branchName: sourceBranch,\n          dag: gitInfo.dag,\n          depthIndents: [],\n        });\n      });\n      console.log(\"\");\n      console.log(`Meta derived stacks:`);\n      metaInfo.sourceBranches.forEach((sourceBranch) => {\n        dfsPrintBranches({\n          currentBranchName: currentBranch.name,\n          branchName: sourceBranch,\n          dag: metaInfo.dag,\n          depthIndents: [],\n        });\n      });\n    }\n  }\n}\n\nfunction dfsPrintBranches(args: {\n  currentBranchName: string;\n  branchName: string;\n  parentName?: string;\n  dag: { [name: string]: string[] };\n  depthIndents: number[];\n}) {\n  const numCommitsSinceParent: number = args.parentName\n    ? +execSync(\n        `git log --oneline ${args.branchName} ^${args.parentName} | wc -l`\n      )\n        .toString()\n        .trim()\n    : 0;\n  const numCommitsSinceChild: number = args.parentName\n    ? +execSync(\n        `git log --oneline ${args.parentName} ^${args.branchName} | wc -l`\n      )\n        .toString()\n        .trim()\n    : 0;\n  console.log(\n    `${args.depthIndents\n      .map((length, i) => `${\" \".repeat(length)}|`)\n      .join(\"\")}${\n      numCommitsSinceChild > 0\n        ? `[${chalk.red(\"*\".repeat(numCommitsSinceChild))}]`\n        : \"\"\n    }->(${\n      args.currentBranchName == args.branchName\n        ? chalk.green(args.branchName)\n        : args.branchName\n    })${\n      numCommitsSinceParent > 0 ? `[${\"*\".repeat(numCommitsSinceParent)}]` : \"\"\n    }`\n  );\n  if (!args.dag[args.branchName]) {\n    return;\n  }\n  args.dag[args.branchName].forEach((childName) =>\n    dfsPrintBranches({\n      parentName: args.branchName,\n      currentBranchName: args.currentBranchName,\n      branchName: childName,\n      dag: args.dag,\n      depthIndents: [\n        ...args.depthIndents,\n        numCommitsSinceParent +\n          args.branchName.length -\n          1 +\n          (numCommitsSinceParent > 0 ? 2 : 0) +\n          4,\n      ],\n    })\n  );\n  console.log(\n    `${args.depthIndents.map((length, i) => `${\" \".repeat(length)}|`).join(\"\")}`\n  );\n}\n","/Users/gregfoster/graphite-cli/src/commands/restack/index.ts",[],"/Users/gregfoster/graphite-cli/src/commands/submit/index.ts",[],"/Users/gregfoster/graphite-cli/src/commands/validate/index.ts",["84","85","86"],"import chalk from \"chalk\";\nimport yargs from \"yargs\";\nimport { log } from \"../../lib/log\";\nimport Branch from \"../../wrapper-classes/branch\";\nimport AbstractCommand from \"../abstract_command\";\n\nconst args = {\n  silent: {\n    describe: `silence output from the command`,\n    demandOption: false,\n    default: false,\n    type: \"boolean\",\n    alias: \"s\",\n  },\n} as const;\ntype argsT = yargs.Arguments<yargs.InferredOptionTypes<typeof args>>;\nexport default class ValidateCommand extends AbstractCommand<typeof args> {\n  static args = args;\n  public async _execute(argv: argsT): Promise<void> {\n    const baseBranch = Branch.getCurrentBranch().getTrunkBranchFromGit();\n    await validateBranch(baseBranch, argv);\n    log(`Current stack is valid`, argv);\n  }\n}\n\nasync function validateBranch(branch: Branch, opts: argsT) {\n  const metaChildren = await branch.getChildrenFromMeta();\n  const gitChildren = branch.getChildrenFromGit();\n  const hasGitChildren = gitChildren && gitChildren.length > 0;\n  const hasMetaChildren = metaChildren.length > 0;\n  if (hasGitChildren && !hasMetaChildren) {\n    throw new Error(`${branch.name} missing a child in sd's meta graph`);\n  }\n  if (!hasGitChildren && hasMetaChildren) {\n    throw new Error(`Unable to find child branches in git for ${branch.name}`);\n  }\n  if (!hasGitChildren && !hasMetaChildren) {\n    // Assume to be a trunk branch and implicately valid.\n    log(`✅ ${chalk.green(`(${branch.name}) validated`)}`, opts);\n    return;\n  }\n  const gitChildrenMissingInMeta = gitChildren!.filter(\n    (gitChild) => !metaChildren!.map((b) => b.name).includes(gitChild.name)\n  );\n  if (gitChildrenMissingInMeta.length > 0) {\n    throw new Error(\n      `Child branches [${gitChildrenMissingInMeta\n        .map((b) => `(${b.name})`)\n        .join(\", \")}] not found in sd's meta graph.`\n    );\n  }\n  log(`✅ ${chalk.green(`(${branch.name}) validated`)}`, opts);\n  for (const child of metaChildren!) {\n    await validateBranch(child, opts);\n  }\n}\n","/Users/gregfoster/graphite-cli/src/index.ts",[],"/Users/gregfoster/graphite-cli/src/lib/log/index.ts",[],"/Users/gregfoster/graphite-cli/src/lib/telemetry/index.ts",["87","88","89","90"],"// Why does an open source CLI include telemetry?\n// We the creators want to understand how people are using the tool\n// All metrics logged are listed plain to see, and are non blocking in case the server is unavailable.\n\nimport { execSync } from \"child_process\";\n\nfunction shouldReportTelemetry(): boolean {\n  return process.env.NODE_ENV != \"development\";\n}\n\nexport function userEmail(): string | undefined {\n  try {\n    return execSync(\"git config user.email\").toString().trim();\n  } catch (err) {\n    return undefined;\n  }\n}\n\nexport async function logCommand(\n  command: string,\n  message?: string\n): Promise<void> {\n  if (shouldReportTelemetry()) {\n    // TODO\n  }\n}\n\nexport async function profile<T>(\n  command: string,\n  handler: () => Promise<void>\n): Promise<void> {\n  void logCommand(command);\n  try {\n    await handler();\n  } catch (err) {\n    void logError(err);\n    throw err;\n  }\n}\n\nexport async function logError(err: Error): Promise<void> {\n  if (shouldReportTelemetry()) {\n    // TODO\n  }\n}\n","/Users/gregfoster/graphite-cli/src/lib/utils/index.ts",[],"/Users/gregfoster/graphite-cli/src/wrapper-classes/branch.ts",[],"/Users/gregfoster/graphite-cli/src/wrapper-classes/commit.ts",["91"],"import { execSync } from \"child_process\";\n\nexport default class Commit {\n  sha: string;\n  constructor(sha: string) {\n    if (sha.length != 40) {\n      throw new Error(\n        `Commit sha must be 40 characters long. Attempted sha = \"${sha}\"`\n      );\n    }\n    this.sha = sha;\n  }\n  public parents(): Commit[] {\n    try {\n      return execSync(`git rev-parse ${this.sha}`)\n        .toString()\n        .trim()\n        .split(\"\\n\")\n        .map((parentSha) => new Commit(parentSha));\n    } catch (e) {\n      return [];\n    }\n  }\n  public setParent(commit: Commit): void {\n    // execSync(`git rebase --onto ${commit.sha} ${this.sha} -Xtheirs`);\n  }\n}\n",{"ruleId":"92","severity":1,"message":"93","line":11,"column":25,"nodeType":"94","messageId":"95","endLine":11,"endColumn":36},{"ruleId":"92","severity":1,"message":"93","line":9,"column":25,"nodeType":"94","messageId":"95","endLine":9,"endColumn":36},{"ruleId":"92","severity":1,"message":"93","line":12,"column":25,"nodeType":"94","messageId":"95","endLine":12,"endColumn":36},{"ruleId":"92","severity":1,"message":"93","line":18,"column":25,"nodeType":"94","messageId":"95","endLine":18,"endColumn":36},{"ruleId":"92","severity":1,"message":"93","line":39,"column":25,"nodeType":"94","messageId":"95","endLine":39,"endColumn":36},{"ruleId":"92","severity":1,"message":"96","line":121,"column":21,"nodeType":"94","messageId":"95","endLine":121,"endColumn":22},{"ruleId":"92","severity":1,"message":"96","line":154,"column":39,"nodeType":"94","messageId":"95","endLine":154,"endColumn":40},{"ruleId":"97","severity":1,"message":"98","line":42,"column":36,"nodeType":"99","messageId":"100","endLine":42,"endColumn":48,"suggestions":"101"},{"ruleId":"97","severity":1,"message":"98","line":43,"column":20,"nodeType":"99","messageId":"100","endLine":43,"endColumn":33,"suggestions":"102"},{"ruleId":"97","severity":1,"message":"98","line":53,"column":23,"nodeType":"99","messageId":"100","endLine":53,"endColumn":36},{"ruleId":"92","severity":1,"message":"103","line":20,"column":3,"nodeType":"94","messageId":"95","endLine":20,"endColumn":18},{"ruleId":"92","severity":1,"message":"104","line":21,"column":3,"nodeType":"94","messageId":"95","endLine":21,"endColumn":19},{"ruleId":"92","severity":1,"message":"105","line":28,"column":31,"nodeType":"94","messageId":"95","endLine":28,"endColumn":32},{"ruleId":"92","severity":1,"message":"106","line":41,"column":32,"nodeType":"94","messageId":"95","endLine":41,"endColumn":42},{"ruleId":"92","severity":1,"message":"107","line":24,"column":20,"nodeType":"94","messageId":"95","endLine":24,"endColumn":34},"@typescript-eslint/no-unused-vars","'argv' is defined but never used.","Identifier","unusedVar","'i' is defined but never used.","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull",["108"],["109"],"'command' is defined but never used.","'message' is defined but never used.","'T' is defined but never used.","'err' is defined but never used.","'commit' is defined but never used.",{"messageId":"110","fix":"111","desc":"112"},{"messageId":"110","fix":"113","desc":"112"},"suggestOptionalChain",{"range":"114","text":"115"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.",{"range":"116","text":"115"},[1523,1524],"?",[1564,1565]]