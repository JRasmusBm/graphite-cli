"use strict";
/**
 * This library reifies typescript types so that we can validate them at runtime.
 *
 * The idea was heavily inspired by https://gcanti.github.io/io-ts/
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.nullable = exports.optional = exports.literals = exports.intersectMany = exports.unionMany = exports.intersection = exports.union = exports.tuple = exports.array = exports.shape = exports.nulltype = exports.boolean = exports.string = exports.number = exports.literal = exports.undefinedtype = void 0;
exports.undefinedtype = (value) => {
    return typeof value === "undefined";
};
function literalWithoutGenericCheck(inner) {
    return (value) => {
        // Not entirely correct, b/c you could have a literal dict, but should work for strings, numbers (might be weird around floats), and booleans
        return JSON.stringify(inner) === JSON.stringify(value);
    };
}
function literal(inner) {
    return literalWithoutGenericCheck(inner);
}
exports.literal = literal;
// JSON Types
exports.number = (value) => {
    return typeof value === "number";
};
exports.string = (value) => {
    return typeof value === "string";
};
exports.boolean = (value) => {
    return typeof value === "boolean";
};
exports.nulltype = (value) => {
    return value === null;
};
/**
 * Note: I'm explicitly excluding dictionaries from this library.
 * I have seen very few legitimate uses of dictionaries in API design
 * and more common than not, the use case is better served by a shape
 * or an array.
 */
function shape(schema) {
    return (value, opts) => {
        // This explicitly allows additional keys so that the validated object
        // can be intersected with other shape types (i.e. value is a superset of schema)
        return (typeof value === "object" &&
            value !== null && // one of my fave JS-isms: typeof null === "object"
            Object.keys(schema).every((key) => {
                const childMatches = schema[key] && schema[key](value[key], opts);
                if (!childMatches && (opts === null || opts === void 0 ? void 0 : opts.logFailures)) {
                    console.log(`Member of shape ${JSON.stringify(value[key])} for ${key} does not match expected type`);
                }
                return childMatches;
            }));
    };
}
exports.shape = shape;
function array(member) {
    return (value, opts) => {
        return (Array.isArray(value) &&
            value.every((v) => {
                const childMatches = member(v, opts);
                if (!childMatches && (opts === null || opts === void 0 ? void 0 : opts.logFailures)) {
                    console.log(`Member of array "${JSON.stringify(v)}" does not match expected type`);
                }
                return childMatches;
            }));
    };
}
exports.array = array;
// Not technically called out in JSON, but we can use JSON for this
function tuple(schema) {
    return (value, opts) => {
        return (Array.isArray(value) &&
            value.length === schema.length &&
            value.every((v, idx) => {
                const childMatches = schema[idx](v, opts);
                if (!childMatches && (opts === null || opts === void 0 ? void 0 : opts.logFailures)) {
                    console.log(`Member of tuple "${JSON.stringify(v)}" does not match expected type`);
                }
                return childMatches;
            }));
    };
}
exports.tuple = tuple;
// Typescript Nonsense
function union(left, right) {
    return (value, opts) => {
        const matches = left(value, opts) || right(value, opts);
        if (!matches && (opts === null || opts === void 0 ? void 0 : opts.logFailures)) {
            console.log(`Member of union "${JSON.stringify(value)}" does not match expected type`);
        }
        return matches;
    };
}
exports.union = union;
function intersection(left, right) {
    return (value, opts) => {
        const matches = left(value, opts) && right(value, opts);
        if (!matches && (opts === null || opts === void 0 ? void 0 : opts.logFailures)) {
            console.log(`Member of intersection "${JSON.stringify(value)}" does not match expected type`);
        }
        return matches;
    };
}
exports.intersection = intersection;
function unionMany(inner) {
    return (value, opts) => {
        const matches = inner.some((schema) => {
            return schema(value, opts);
        });
        if (!matches && (opts === null || opts === void 0 ? void 0 : opts.logFailures)) {
            console.log(`Member of union-many ${JSON.stringify(value)} does not expected type`);
        }
        return matches;
    };
}
exports.unionMany = unionMany;
function intersectMany(inner) {
    return (value, opts) => {
        const matches = inner.every((schema) => {
            return schema(value, opts);
        });
        if (!matches && (opts === null || opts === void 0 ? void 0 : opts.logFailures)) {
            console.log(`Member of intersection-many ${JSON.stringify(value)} does not expected type`);
        }
        return matches;
    };
}
exports.intersectMany = intersectMany;
// Helpers
function literals(
// See below for why we exclude booleans here
inners) {
    return unionMany(inners.map((value) => {
        // Note: we intentionally don't use literal(). The reason is that would
        // break literals([true, false] as const)
        //
        // This is because when we call literal() we need to know what type it's being
        // called with (b/c there is only one lambda in the map), and so logically that
        // type is inferred as the union of all members of the array. When we pass this function
        // an array that contains both true and false, the type of literal is infered as
        // literal<true|false>(value: NonGeneric<true|false>), our mistake catching code in
        // NonGeneric detects that boolean extends true|false and flags it (assuming you simply
        // called literal() without as const, e.g. literal(false) errors b/c it gets infered to
        // literal<boolean>(false))
        return literalWithoutGenericCheck(value);
    }));
}
exports.literals = literals;
function optional(inner) {
    return union(inner, exports.undefinedtype);
}
exports.optional = optional;
function nullable(inner) {
    return union(inner, exports.nulltype);
}
exports.nullable = nullable;
//# sourceMappingURL=index.js.map