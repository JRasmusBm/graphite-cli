/**
 * This library reifies typescript types so that we can validate them at runtime.
 *
 * The idea was heavily inspired by https://gcanti.github.io/io-ts/
 */
declare type TOpts = {
    logFailures: boolean;
};
export declare type Schema<TInner> = (value: unknown, opts?: TOpts) => value is TInner;
declare type ExtractTypeguard<T> = T extends (v: unknown, o?: TOpts) => v is infer U ? U : never;
export declare type TypeOf<A extends Schema<unknown>> = ExtractTypeguard<A>;
export declare type UnwrapSchemaMap<TSchemaMap> = keyof TSchemaMap extends never ? {
    [K in any]: undefined;
} : {
    [SchemaMapIndex in keyof TSchemaMap]: TSchemaMap[SchemaMapIndex] extends Schema<unknown> ? TypeOf<TSchemaMap[SchemaMapIndex]> : never;
};
export declare const undefinedtype: (value: unknown) => value is undefined;
declare type Extends<A, B> = [A] extends [B] ? true : false;
declare type NonGenericExceptBooleans<A> = true extends Extends<string, A> | Extends<number, A> ? never : A;
declare type NonGeneric<A> = true extends Extends<boolean, A> ? never : NonGenericExceptBooleans<A>;
export declare function literal<TInner>(inner: NonGeneric<TInner>): (value: unknown) => value is NonGeneric<TInner>;
export declare const number: (value: unknown) => value is number;
export declare const string: (value: unknown) => value is string;
export declare const boolean: (value: unknown) => value is boolean;
export declare const nulltype: (value: unknown) => value is null;
/**
 * Note: I'm explicitly excluding dictionaries from this library.
 * I have seen very few legitimate uses of dictionaries in API design
 * and more common than not, the use case is better served by a shape
 * or an array.
 */
export declare function shape<TDefnSchema extends {
    [key: string]: Schema<unknown>;
}, TDefn extends {
    [DefnIndex in keyof TDefnSchema]: TypeOf<TDefnSchema[DefnIndex]>;
}>(schema: TDefnSchema): (value: unknown, opts?: TOpts | undefined) => value is TDefn;
export declare function array<TMember>(member: Schema<TMember>): (value: unknown, opts?: TOpts | undefined) => value is TMember[];
export declare function tuple<TDefnSchema extends readonly Schema<unknown>[], TDefn extends {
    [DefnIndex in keyof TDefnSchema]: TDefnSchema[DefnIndex] extends Schema<unknown> ? TypeOf<TDefnSchema[DefnIndex]> : never;
} & {
    length: TDefnSchema["length"];
}>(schema: TDefnSchema): (value: unknown, opts?: TOpts | undefined) => value is TDefn;
export declare function union<TLeft, TRight>(left: Schema<TLeft>, right: Schema<TRight>): (value: unknown, opts?: TOpts | undefined) => value is TLeft | TRight;
export declare function intersection<TLeft, TRight>(left: Schema<TLeft>, right: Schema<TRight>): (value: unknown, opts?: TOpts | undefined) => value is TLeft & TRight;
export declare function unionMany<TSchema extends Schema<unknown>, TInnerSchemaType extends TypeOf<TSchema>>(inner: TSchema[]): (value: unknown, opts?: TOpts | undefined) => value is TInnerSchemaType;
declare type TPluralIntersectionType<T> = (T extends Schema<infer U> ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export declare function intersectMany<TSchema extends Schema<unknown>, TInnerSchemaType extends TPluralIntersectionType<TSchema>>(inner: TSchema[]): (value: unknown, opts?: TOpts | undefined) => value is TInnerSchemaType;
export declare function literals<TLiterals>(inners: readonly NonGenericExceptBooleans<TLiterals>[]): (value: unknown, opts?: TOpts | undefined) => value is NonGenericExceptBooleans<TLiterals>;
export declare function optional<TInner>(inner: Schema<TInner>): (value: unknown, opts?: TOpts | undefined) => value is TInner | undefined;
export declare function nullable<TInner>(inner: Schema<TInner>): (value: unknown, opts?: TOpts | undefined) => value is TInner | null;
export {};
